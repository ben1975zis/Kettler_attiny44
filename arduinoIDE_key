/*
 * УМНЫЙ ЧАЙНИК для ATtiny44A
 */

#include <avr/wdt.h>
#include <avr/eeprom.h>
#include <util/delay.h>

// =============================================================================
// HARDWARE CONFIG (соответствует нетлисту)
// =============================================================================
#define LED_R       PB2
#define LED_G       PA7
#define LED_B       PA6
#define BUZZER      PA0
#define RELAY       PA4
#define TEMP_ADC    1

#define A_1_2       PB0  // KEY2
#define A_3_4       PA2  // KEY1
#define C_1_3       PA3
#define C_2_4       PB1

// =============================================================================
// ТИПЫ ДАННЫХ
// =============================================================================
enum BtnEvent { NONE, BTN1_CLICK, BTN1_HOLD, BTN2_CLICK, BTN2_HOLD_SHORT, BTN2_HOLD_LONG };

// =============================================================================
// STATE MACHINE
// =============================================================================
enum State {
  OFF,
  SELECTING,
  HEATING,
  BOILING,
  ALARMING,
  ERROR
};

// =============================================================================
// CONFIGURATION
// =============================================================================
const int16_t TEMP_PRESETS[] = {4000, 6000, 7000, 8000, 9000};
const uint8_t PRESET_COLORS[] = {160, 96, 64, 32, 16};

#define TEMP_MAX         10300
#define TEMP_MIN         715
#define TEMP_BOIL        9500

#define TIME_MAX_HEATING  2097152
#define TIME_TEMP_STUCK   262144
#define TIME_ALARM        15000
#define TIME_DEBOUNCE     200
#define TIME_HOLD_SHORT   3000
#define TIME_HOLD_LONG    12000
#define TIME_SELECT       12000

// =============================================================================
// GLOBAL STATE
// =============================================================================
State state = OFF;

int16_t temp_now = 2000;
int16_t temp_target = 0;
int16_t temp_compensation = -150;

uint8_t preset_idx = 0;

uint32_t state_enter_time = 0;
uint32_t temp_last_change = 0;

bool alarm_active = false;
uint32_t alarm_start = 0;

uint8_t anim_hue = 0;
uint8_t anim_bright = 0;
bool anim_dir = true;

// === Флаги безопасности и удобства ===
uint8_t dry_check_active = 0;
uint32_t auto_off_timer = 0;
bool auto_off_enabled = false;

// =============================================================================
// HARDWARE ABSTRACTION
// =============================================================================

void rgb(uint8_t r, uint8_t g, uint8_t b) {
  OCR0A = 255 - r;
  OCR0B = 255 - g;
  OCR1A = 255 - b;
}

void hsv(uint8_t h, uint8_t v = 255) {
  uint8_t s = h / 43, f = (h % 43) * 6;
  uint8_t q = (v * (255 - f)) >> 8;
  uint8_t t = (v * f) >> 8;
  
  switch(s) {
    case 0: rgb(v, t, 0); break;
    case 1: rgb(q, v, 0); break;
    case 2: rgb(0, v, t); break;
    case 3: rgb(0, q, v); break;
    case 4: rgb(t, 0, v); break;
    default: rgb(v, 0, q);
  }
}

void led_off() { rgb(0, 0, 0); }

uint8_t temp_to_color(int16_t t) {
  if (t < 1829) return 7;
  if (t > 9500) return 0;
  return t / 31 - 51;
}

void show_led(uint8_t n) {
  DDRA &= ~(_BV(A_3_4) | _BV(C_1_3));
  DDRB &= ~(_BV(A_1_2) | _BV(C_2_4));
  PORTA |= _BV(A_3_4);
  PORTB |= _BV(A_1_2);

  if (n == 0) return;

  if (n >= 1 && n <= 3) {
    PORTB |= _BV(A_1_2);
    DDRB |= _BV(A_1_2);
    PORTA &= ~_BV(A_3_4);
    DDRA |= _BV(A_3_4);
  } else if (n == 4 || n == 5) {
    PORTA |= _BV(A_3_4);
    DDRA |= _BV(A_3_4);
    PORTB &= ~_BV(A_1_2);
    DDRB |= _BV(A_1_2);
  }

  switch(n) {
    case 1:
      PORTA &= ~_BV(C_1_3);
      DDRA |= _BV(C_1_3);
      break;
    case 2:
    case 3:
      PORTB &= ~_BV(C_2_4);
      DDRB |= _BV(C_2_4);
      break;
    case 4:
      PORTA &= ~_BV(C_1_3);
      DDRA |= _BV(C_1_3);
      break;
    case 5:
      PORTA &= ~_BV(C_1_3);
      DDRA |= _BV(C_1_3);
      PORTB &= ~_BV(C_2_4);
      DDRB |= _BV(C_2_4);
      break;
  }
}

void beep(uint16_t freq_hz, uint16_t duration_ms) {
  if (!freq_hz) { 
    _delay_ms(duration_ms); 
    return; 
  }
  
  uint32_t cycles = (uint32_t)duration_ms * freq_hz / 1000;
  uint16_t half = 500000UL / freq_hz;
  
  for (uint32_t i = 0; i < cycles; i++) {
    PORTA ^= _BV(BUZZER);
    _delay_us(half);
  }
  PORTA |= _BV(BUZZER);
}

void beep_click() { beep(512, 50); }
void beep_done() { beep(2048, 100); _delay_ms(1000); }
void beep_error() { hsv(0); beep(2048, 500); led_off(); _delay_ms(500); }

int16_t read_temp_raw() {
  static int16_t hist[3];
  static uint8_t idx = 0;
  
  ADCSRA |= _BV(ADSC);
  while (ADCSRA & _BV(ADSC));
  hist[idx++] = ADC;
  idx %= 3;
  
  int16_t a = hist[0], b = hist[1], c = hist[2];
  int16_t mid = (a < b) ? ((b < c) ? b : ((c < a) ? a : c)) 
                        : ((a < c) ? a : ((c < b) ? b : c));
  
  return (mid > 558) ? (18291 - mid * 26) : (13820 - mid * 18);
}

void update_temp() {
  int16_t raw = read_temp_raw();
  temp_now += (raw - temp_now) / 32;
  
  static int16_t last_stable = 0;
  if (abs(temp_now - last_stable) > 100) {
    temp_last_change = millis();
    last_stable = temp_now;
  }
}

BtnEvent read_button() {
  static uint8_t last = 0;
  static uint32_t press_time = 0;
  static uint8_t hold_level = 0;
  
  show_led(0);
  _delay_us(100);
  
  uint8_t btn = 0;
  if (!(PINA & _BV(A_3_4))) btn = 1;
  else if (!(PINB & _BV(A_1_2))) btn = 2;
  
  show_led(preset_idx + 1);
  
  BtnEvent evt = NONE;
  
  if (btn && btn == last) {
    uint32_t held = millis() - press_time;
    
    if (hold_level == 0 && held > TIME_DEBOUNCE) {
      hold_level = 1;
      press_time = millis();
      beep_click();
      
      if (alarm_active) alarm_active = false;
      if (btn == 1 && state == OFF) hsv(0);
    }
    else if (hold_level == 1 && held > TIME_HOLD_SHORT) {
      hold_level = 2;
      beep_click();
    }
    else if (hold_level == 2 && held > TIME_HOLD_LONG - TIME_HOLD_SHORT) {
      hold_level = 3;
      beep_click();
    }
  }
  else if (!btn && last) {
    if (millis() - press_time > TIME_DEBOUNCE) {
      if (last == 1) {
        evt = (hold_level < 2) ? BTN1_CLICK : BTN1_HOLD;
      } else {
        if (hold_level == 1) evt = BTN2_CLICK;
        else if (hold_level == 2) evt = BTN2_HOLD_SHORT;
        else if (hold_level == 3) evt = BTN2_HOLD_LONG;
      }
    }
    hold_level = 0;
    press_time = millis();
  }
  
  last = btn;
  return evt;
}

void update_led_effect() {
  static uint32_t last_frame = 0;
  if (millis() - last_frame < 25) return;
  last_frame = millis();
  
  if (anim_bright == 0) {
    anim_dir = true;
    anim_hue = temp_to_color(temp_now);
  }
  anim_bright += anim_dir ? 1 : -1;
  if (anim_bright == 255) anim_dir = false;
  
  hsv(anim_hue, anim_bright);
}

void update_alarm() {
  if (!alarm_active) return;
  
  uint32_t elapsed = millis() - alarm_start;
  if (elapsed > TIME_ALARM) {
    alarm_active = false;
    PORTA |= _BV(BUZZER);
    return;
  }
  
  if ((elapsed / 500) % 2 == 0) {
    PORTA &= ~_BV(BUZZER);
  } else {
    PORTA |= _BV(BUZZER);
  }
}

void enter_state(State s) {
  state = s;
  state_enter_time = millis();
  
  if (s == OFF) {
    PORTA &= ~_BV(RELAY);
    DDRA |= _BV(RELAY);
    led_off();
    preset_idx = 0;
    dry_check_active = 0;
    auto_off_enabled = false;
  }
  else if (s == SELECTING) {
    preset_idx = eeprom_read_byte((uint8_t*)0);
    if (preset_idx > 4) preset_idx = 0;
    show_led(preset_idx + 1);
    hsv(PRESET_COLORS[preset_idx]);
  }
  else if (s == HEATING || s == BOILING) {
    show_led(0);
    led_off();
    PORTA |= _BV(RELAY);
    DDRA |= _BV(RELAY);
    temp_last_change = millis();
    temp_compensation = -150;
    anim_hue = 0;
    anim_bright = 0;
    dry_check_active = 1;
  }
  else if (s == ALARMING) {
    PORTA &= ~_BV(RELAY);
    DDRA |= _BV(RELAY);
    alarm_active = true;
    alarm_start = millis();
    auto_off_enabled = true;
    auto_off_timer = millis();
  }
  else if (s == ERROR) {
    PORTA &= ~_BV(RELAY);
    DDRA |= _BV(RELAY);
    alarm_active = false;
  }
}

void handle_off(BtnEvent btn) {
  if (temp_now > 6500) {
    if (btn != NONE) {
      enter_state(ERROR);
    }
    return;
  }

  if (btn == BTN1_CLICK) {
    enter_state(BOILING);
  }
  else if (btn == BTN2_CLICK) {
    enter_state(SELECTING);
  }
}

void handle_selecting(BtnEvent btn) {
  if (btn == BTN1_CLICK) {
    enter_state(OFF);
  }
  else if (btn == BTN2_CLICK) {
    preset_idx = (preset_idx + 1) % 5;
    show_led(preset_idx + 1);
    hsv(PRESET_COLORS[preset_idx]);
    state_enter_time = millis();
  }
  else if (btn == BTN2_HOLD_SHORT) {
    eeprom_update_byte((uint8_t*)0, preset_idx);
    show_led(0);
    _delay_ms(250);
    show_led(preset_idx + 1);
  }
  
  if (millis() - state_enter_time > TIME_SELECT) {
    temp_target = TEMP_PRESETS[preset_idx];
    if (temp_now < temp_target - 350) {
      enter_state(HEATING);
    } else {
      enter_state(OFF);
    }
  }
}

void handle_heating_boiling(BtnEvent btn) {
  if (dry_check_active) {
    uint32_t elapsed = millis() - state_enter_time;
    if (elapsed > 15000) {
      dry_check_active = 0;
    } else if (elapsed > 5000 && temp_now > 7000) {
      enter_state(ERROR);
      beep_error();
      return;
    }
  }

  update_led_effect();
  
  if (btn == BTN1_CLICK) {
    enter_state(OFF);
    return;
  }
  
  if (millis() - state_enter_time > TIME_MAX_HEATING) {
    enter_state(ERROR);
    beep_error(); beep_error(); beep_error();
    return;
  }
  
  if (millis() - temp_last_change > TIME_TEMP_STUCK) {
    enter_state(ERROR);
    beep_error(); beep_error();
    return;
  }
  
  static int16_t last_calc = 0;
  static uint32_t calc_time = 0;
  
  if (last_calc == 0) {
    last_calc = temp_now;
    calc_time = millis();
  }
  else if (temp_now > last_calc + 100) {
    uint32_t dt = millis() - calc_time;
    if (dt > 1000) {
      uint16_t rate = (temp_now - last_calc) * 10000UL / dt;
      if (rate >= 1300) temp_compensation = -1180;
      else if (rate > 720) temp_compensation = 120 - rate;
      else if (rate > 200) temp_compensation = 253796UL / rate - 933;
      else temp_compensation = 350;
      
      last_calc = temp_now;
      calc_time = millis();
    }
  }
  
  if (state == HEATING) {
    if (temp_now >= temp_target + temp_compensation) {
      enter_state(ALARMING);
    }
  }
  else {
    static uint32_t boil_start = 0;
    
    if (temp_now > TEMP_BOIL && boil_start == 0) {
      boil_start = millis();
    }
    
    if (boil_start > 0) {
      uint32_t boil_time = 16000;
      uint32_t elapsed = millis() - calc_time;
      if (elapsed > 0 && elapsed < 10000) {
        uint16_t rate = (temp_now - last_calc) * 10000UL / elapsed;
        if (rate > 0) {
          boil_time = 19082305UL / (rate > 3000 ? 3000 : (rate < 272 ? 272 : rate)) + 5375;
        }
      }
      
      if (millis() - boil_start > boil_time) {
        enter_state(ALARMING);
      }
    }
  }
}

void handle_alarming(BtnEvent btn) {
  if (btn != NONE) {
    auto_off_enabled = false; // отключить автоотключение при взаимодействии
    alarm_active = false;
    enter_state(OFF);
  }
}

void handle_error(BtnEvent btn) {
  hsv(0);
  _delay_ms(500);
  led_off();
  _delay_ms(500);
  
  if (btn != NONE) enter_state(OFF);
}

void setup() {
  wdt_enable(WDTO_8S);
  
  DDRA = _BV(LED_G) | _BV(LED_B) | _BV(BUZZER) | _BV(RELAY);
  DDRB = _BV(LED_R);
  PORTA = _BV(A_3_4);
  PORTB = _BV(A_1_2);

  TCCR0A = _BV(COM0A1) | _BV(COM0B1) | _BV(WGM01) | _BV(WGM00);
  TCCR0B = _BV(CS01);
  TCCR1A = _BV(WGM10) | _BV(COM1A1);
  TCCR1B = _BV(WGM12) | _BV(CS11);
  
  ADMUX = _BV(REFS0) | TEMP_ADC;
  ADCSRA = _BV(ADEN) | _BV(ADPS2) | _BV(ADPS1);
  
  beep_click();
  for (int i = 0; i < 3; i++) { read_temp_raw(); _delay_ms(50); }
  update_temp();
  
  uint8_t c = temp_to_color(temp_now);
  for (int i = 1; i <= 255; i++) {
    hsv(c, i);
    _delay_us(2000);
    if (!(PINA & _BV(A_3_4)) || !(PINB & _BV(A_1_2))) break;
  }
  for (int i = 255; i > 0; i--) {
    hsv(c, i);
    _delay_us(2000);
    if (!(PINA & _BV(A_3_4)) || !(PINB & _BV(A_1_2))) break;
  }
  led_off();
}

void loop() {
  wdt_reset();
  
  update_alarm();
  update_temp();
  
  if (temp_now >= TEMP_MAX) {
    enter_state(ERROR);
    alarm_active = false;
    beep_error();
    return;
  }
  
  if (temp_now < TEMP_MIN) {
    if (state != ERROR) enter_state(ERROR);
    return;
  }
  
  // === АВТООТКЛЮЧЕНИЕ "ЗАБЫТОГО ЧАЙНИКА" ЧЕРЕЗ 2 МИНУТЫ ===
  if (auto_off_enabled && state == ALARMING) {
    if (millis() - auto_off_timer > 120000) {
      enter_state(OFF);
    }
  }
  
  BtnEvent btn = read_button();
  
  switch(state) {
    case OFF:       handle_off(btn); break;
    case SELECTING: handle_selecting(btn); break;
    case HEATING:
    case BOILING:   handle_heating_boiling(btn); break;
    case ALARMING:  handle_alarming(btn); break;
    case ERROR:     handle_error(btn); break;
  }
  
  _delay_ms(5);
}

/*
 * УМНЫЙ ЧАЙНИК для ATtiny44A
  */

#include <avr/wdt.h>
#include <avr/eeprom.h>

// =============================================================================
// HARDWARE CONFIG (соответствует нетлисту + PB3 вместо PA0)
// =============================================================================
#define LED_R       PB2  // PWM OC0A → pin 5
#define LED_G       PA7  // PWM OC0B → pin 6
#define LED_B       PA6  // PWM OC1A → pin 7
#define BUZZER      PA5  // → pin 8
#define RELAY       PA4  // → pin 9
#define TEMP_ADC    1    // ADC1 (PA1 → pin 12)

// LED Matrix + Buttons
#define A_1_2       PB3  // аноды 1-2 → pin 4 (KEY1) ← ИСПРАВЛЕНО!
#define A_3_4       PA2  // аноды 3-4 → pin 11 (KEY2)
#define C_1_3       PA3  // катоды 1,3 → pin 10
#define C_2_4       PB1  // катоды 2,4 → pin 3

// =============================================================================
// ТИПЫ ДАННЫХ
// =============================================================================
enum BtnEvent { NONE, BTN1_CLICK, BTN1_HOLD, BTN2_CLICK, BTN2_HOLD_SHORT, BTN2_HOLD_LONG };

// =============================================================================
// STATE MACHINE
// =============================================================================
enum State {
  OFF,           // Idle, waiting
  SELECTING,     // User choosing temperature
  HEATING,       // Heating to preset temp
  BOILING,       // Boiling mode
  ALARMING,      // Done, beeping
  ERROR          // Something wrong
};

// =============================================================================
// CONFIGURATION
// =============================================================================
const int16_t TEMP_PRESETS[] = {4000, 6000, 7000, 8000, 9000}; // 40-90°C
const uint8_t PRESET_COLORS[] = {160, 96, 64, 32, 16};

#define TEMP_MAX         10300  // Overheat protection
#define TEMP_MIN         715    // Sensor error detection
#define TEMP_BOIL        9500   // Start boiling countdown

#define TIME_MAX_HEATING  2097152  // ~8.7 min
#define TIME_TEMP_STUCK   262144   // ~65 sec
#define TIME_ALARM        15000    // 15s beeping
#define TIME_DEBOUNCE     200      // 50ms debounce
#define TIME_HOLD_SHORT   3000     // 750ms short hold
#define TIME_HOLD_LONG    12000    // 3s long hold
#define TIME_SELECT       12000    // 3s selection timeout

// =============================================================================
// GLOBAL STATE
// =============================================================================
State state = OFF;

int16_t temp_now = 2000;
int16_t temp_target = 0;
int16_t temp_compensation = -150;

uint8_t preset_idx = 0;

uint32_t state_enter_time = 0;
uint32_t temp_last_change = 0;

bool alarm_active = false;
uint32_t alarm_start = 0;

uint8_t anim_hue = 0;
uint8_t anim_bright = 0;
bool anim_dir = true;

// =============================================================================
// HARDWARE ABSTRACTION
// =============================================================================

// --- RGB LED ---
void rgb(uint8_t r, uint8_t g, uint8_t b) {
  OCR0A = 255 - r;
  OCR0B = 255 - g;
  OCR1A = 255 - b;
}

void hsv(uint8_t h, uint8_t v = 255) {
  uint8_t s = h / 43, f = (h % 43) * 6;
  uint8_t q = (v * (255 - f)) >> 8;
  uint8_t t = (v * f) >> 8;
  
  switch(s) {
    case 0: rgb(v, t, 0); break;
    case 1: rgb(q, v, 0); break;
    case 2: rgb(0, v, t); break;
    case 3: rgb(0, q, v); break;
    case 4: rgb(t, 0, v); break;
    default: rgb(v, 0, q);
  }
}

void led_off() { rgb(0, 0, 0); }

// --- Temperature to Color ---
uint8_t temp_to_color(int16_t t) {
  if (t < 1829) return 7;
  if (t > 9500) return 0;
  return t / 31 - 51;
}

// --- Matrix LED Indicator ---
void show_led(uint8_t n) {
  // Сброс: все пины в INPUT_PULLUP
  DDRA &= ~(_BV(A_3_4) | _BV(C_1_3));
  DDRB &= ~(_BV(A_1_2) | _BV(C_2_4));
  PORTA |= _BV(A_3_4);
  PORTB |= _BV(A_1_2);  // PB3 с подтяжкой

  if (n == 0) return;

  if (n >= 1 && n <= 3) {
    // Аноды 1-2: PB3 = HIGH
    PORTB |= _BV(A_1_2);
    DDRB |= _BV(A_1_2);
    PORTA &= ~_BV(A_3_4);
    DDRA |= _BV(A_3_4);
  } else if (n == 4 || n == 5) {
    // Аноды 3-4: PA2 = HIGH
    PORTA |= _BV(A_3_4);
    DDRA |= _BV(A_3_4);
    PORTB &= ~_BV(A_1_2);
    DDRB |= _BV(A_1_2);
  }

  switch(n) {
    case 1: // LED1: C_1_3 = LOW
      PORTA &= ~_BV(C_1_3);
      DDRA |= _BV(C_1_3);
      break;
    case 2: // LED2: C_2_4 = LOW
      PORTB &= ~_BV(C_2_4);
      DDRB |= _BV(C_2_4);
      break;
    case 3: // LED3: C_2_4 = LOW
      PORTB &= ~_BV(C_2_4);
      DDRB |= _BV(C_2_4);
      break;
    case 4: // LED4: C_1_3 = LOW
      PORTA &= ~_BV(C_1_3);
      DDRA |= _BV(C_1_3);
      break;
    case 5: // LED5: LED3 + LED4
      PORTA &= ~_BV(C_1_3);
      DDRA |= _BV(C_1_3);
      PORTB &= ~_BV(C_2_4);
      DDRB |= _BV(C_2_4);
      break;
  }
}

// --- Buzzer ---
void beep(uint16_t freq_hz, uint16_t duration_ms) {
  if (!freq_hz) { delay(duration_ms); return; }
  
  uint32_t cycles = (uint32_t)duration_ms * freq_hz / 1000;
  uint16_t half = 500000UL / freq_hz;
  
  for (uint32_t i = 0; i < cycles; i++) {
    PORTA ^= _BV(BUZZER);
    delayMicroseconds(half);
  }
  PORTA |= _BV(BUZZER);
}

void beep_click() { beep(512, 50); }
void beep_done() { beep(2048, 100); delay(1000); }
void beep_error() { hsv(0); beep(2048, 500); led_off(); delay(500); }

// --- Temperature Sensor ---
int16_t read_temp_raw() {
  static int16_t hist[3];
  static uint8_t idx = 0;
  
  hist[idx++] = analogRead(TEMP_ADC);
  idx %= 3;
  
  int16_t a = hist[0], b = hist[1], c = hist[2];
  int16_t mid = (a < b) ? ((b < c) ? b : ((c < a) ? a : c)) 
                        : ((a < c) ? a : ((c < b) ? b : c));
  
  return (mid > 558) ? (18291 - mid * 26) : (13820 - mid * 18);
}

void update_temp() {
  int16_t raw = read_temp_raw();
  temp_now += (raw - temp_now) / 32;
  
  static int16_t last_stable = 0;
  if (abs(temp_now - last_stable) > 100) {
    temp_last_change = millis();
    last_stable = temp_now;
  }
}

// --- Buttons ---
BtnEvent read_button() {
  static uint8_t last = 0;
  static uint32_t press_time = 0;
  static uint8_t hold_level = 0;
  
  show_led(0);
  delayMicroseconds(100);
  
  uint8_t btn = 0;
  if (!(PINB & _BV(A_1_2))) btn = 1; // KEY1 → PB3
  else if (!(PINA & _BV(A_3_4))) btn = 2; // KEY2 → PA2
  
  show_led(preset_idx + 1);
  
  BtnEvent evt = NONE;
  
  if (btn && btn == last) {
    uint32_t held = millis() - press_time;
    
    if (hold_level == 0 && held > TIME_DEBOUNCE) {
      hold_level = 1;
      press_time = millis();
      beep_click();
      
      if (alarm_active) alarm_active = false;
      if (btn == 1 && state == OFF) hsv(0);
    }
    else if (hold_level == 1 && held > TIME_HOLD_SHORT) {
      hold_level = 2;
      beep_click();
    }
    else if (hold_level == 2 && held > TIME_HOLD_LONG - TIME_HOLD_SHORT) {
      hold_level = 3;
      beep_click();
    }
  }
  else if (!btn && last) {
    if (millis() - press_time > TIME_DEBOUNCE) {
      if (last == 1) {
        evt = (hold_level < 2) ? BTN1_CLICK : BTN1_HOLD;
      } else {
        if (hold_level == 1) evt = BTN2_CLICK;
        else if (hold_level == 2) evt = BTN2_HOLD_SHORT;
        else if (hold_level == 3) evt = BTN2_HOLD_LONG;
      }
    }
    hold_level = 0;
    press_time = millis();
  }
  
  last = btn;
  return evt;
}

// =============================================================================
// LED EFFECTS
// =============================================================================
void update_led_effect() {
  static uint32_t last_frame = 0;
  if (millis() - last_frame < 25) return;
  last_frame = millis();
  
  if (anim_bright == 0) {
    anim_dir = true;
    anim_hue = temp_to_color(temp_now);
  }
  anim_bright += anim_dir ? 1 : -1;
  if (anim_bright == 255) anim_dir = false;
  
  hsv(anim_hue, anim_bright);
}

// =============================================================================
// ALARM
// =============================================================================
void update_alarm() {
  if (!alarm_active) return;
  
  uint32_t elapsed = millis() - alarm_start;
  if (elapsed > TIME_ALARM) {
    alarm_active = false;
    PORTA |= _BV(BUZZER);
    return;
  }
  
  if ((elapsed / 500) % 2 == 0) {
    PORTA &= ~_BV(BUZZER);
  } else {
    PORTA |= _BV(BUZZER);
  }
}

// =============================================================================
// STATE TRANSITIONS
// =============================================================================
void enter_state(State s) {
  state = s;
  state_enter_time = millis();
  
  switch(s) {
    case OFF:
      PORTA &= ~_BV(RELAY);
      DDRA |= _BV(RELAY);
      led_off();
      preset_idx = 0;
      break;
      
    case SELECTING:
      preset_idx = eeprom_read_byte((uint8_t*)0);
      if (preset_idx > 4) preset_idx = 0;
      show_led(preset_idx + 1);
      hsv(PRESET_COLORS[preset_idx]);
      break;
      
    case HEATING:
    case BOILING:
      show_led(0);
      led_off();
      PORTA |= _BV(RELAY);
      DDRA |= _BV(RELAY);
      temp_last_change = millis();
      temp_compensation = -150;
      anim_hue = 0;
      anim_bright = 0;
      break;
      
    case ALARMING:
      PORTA &= ~_BV(RELAY);
      DDRA |= _BV(RELAY);
      alarm_active = true;
      alarm_start = millis();
      break;
      
    case ERROR:
      PORTA &= ~_BV(RELAY);
      DDRA |= _BV(RELAY);
      alarm_active = false;
      break;
  }
}

// =============================================================================
// STATE HANDLERS
// =============================================================================

void handle_off(BtnEvent btn) {
  if (btn == BTN1_CLICK) {
    enter_state(BOILING);
  }
  else if (btn == BTN2_CLICK) {
    enter_state(SELECTING);
  }
}

void handle_selecting(BtnEvent btn) {
  if (btn == BTN1_CLICK) {
    enter_state(OFF);
  }
  else if (btn == BTN2_CLICK) {
    preset_idx = (preset_idx + 1) % 5;
    show_led(preset_idx + 1);
    hsv(PRESET_COLORS[preset_idx]);
    state_enter_time = millis();
  }
  else if (btn == BTN2_HOLD_SHORT) {
    eeprom_update_byte((uint8_t*)0, preset_idx);
    show_led(0);
    delay(250);
    show_led(preset_idx + 1);
  }
  
  if (millis() - state_enter_time > TIME_SELECT) {
    temp_target = TEMP_PRESETS[preset_idx];
    if (temp_now < temp_target - 350) {
      enter_state(HEATING);
    } else {
      enter_state(OFF);
    }
  }
}

void handle_heating_boiling(BtnEvent btn) {
  update_led_effect();
  
  if (btn == BTN1_CLICK) {
    enter_state(OFF);
    return;
  }
  
  if (millis() - state_enter_time > TIME_MAX_HEATING) {
    enter_state(ERROR);
    beep_error(); beep_error(); beep_error();
    return;
  }
  
  if (millis() - temp_last_change > TIME_TEMP_STUCK) {
    enter_state(ERROR);
    beep_error(); beep_error();
    return;
  }
  
  static int16_t last_calc = 0;
  static uint32_t calc_time = 0;
  
  if (last_calc == 0) {
    last_calc = temp_now;
    calc_time = millis();
  }
  else if (temp_now > last_calc + 100) {
    uint32_t dt = millis() - calc_time;
    if (dt > 1000) {
      uint16_t rate = (temp_now - last_calc) * 10000UL / dt;
      if (rate >= 1300) temp_compensation = -1180;
      else if (rate > 720) temp_compensation = 120 - rate;
      else if (rate > 200) temp_compensation = 253796UL / rate - 933;
      else temp_compensation = 350;
      
      last_calc = temp_now;
      calc_time = millis();
    }
  }
  
  if (state == HEATING) {
    if (temp_now >= temp_target + temp_compensation) {
      enter_state(ALARMING);
    }
  }
  else { // BOILING
    static uint32_t boil_start = 0;
    
    if (temp_now > TEMP_BOIL && boil_start == 0) {
      boil_start = millis();
    }
    
    if (boil_start > 0) {
      uint32_t boil_time = 16000;
      uint32_t elapsed = millis() - calc_time;
      if (elapsed > 0 && elapsed < 10000) {
        uint16_t rate = (temp_now - last_calc) * 10000UL / elapsed;
        if (rate > 0) {
          boil_time = 19082305UL / constrain(rate, 272, 3000) + 5375;
        }
      }
      
      if (millis() - boil_start > boil_time) {
        enter_state(ALARMING);
      }
    }
  }
}

void handle_alarming(BtnEvent btn) {
  if (btn != NONE) {
    alarm_active = false;
    enter_state(OFF);
  }
}

void handle_error(BtnEvent btn) {
  hsv(0);
  delay(500);
  led_off();
  delay(500);
  
  if (btn != NONE) enter_state(OFF);
}

// =============================================================================
// SETUP
// =============================================================================
void setup() {
  wdt_enable(WDTO_8S);
  
  // GPIO
  DDRA = _BV(LED_G) | _BV(LED_B) | _BV(BUZZER) | _BV(RELAY);
  DDRB = _BV(LED_R);
  PORTA = _BV(BUZZER) | _BV(A_3_4);
  PORTB = _BV(A_1_2);  // PB3 — подтяжка для KEY1

  // PWM setup
  TCCR0A = _BV(COM0A1) | _BV(COM0B1) | _BV(WGM01) | _BV(WGM00);
  TCCR0B = _BV(CS01);
  TCCR1A = _BV(WGM10) | _BV(COM1A1);
  TCCR1B = _BV(WGM12) | _BV(CS11);
  
  // Init
  beep_click();
  for (int i = 0; i < 3; i++) { read_temp_raw(); delay(50); }
  update_temp();
  
  // Boot animation
  uint8_t c = temp_to_color(temp_now);
  for (int i = 1; i <= 255; i++) {
    hsv(c, i);
    delayMicroseconds(2000);
    if (!(PINB & _BV(A_1_2)) || !(PINA & _BV(A_3_4))) break;
  }
  for (int i = 255; i > 0; i--) {
    hsv(c, i);
    delayMicroseconds(2000);
    if (!(PINB & _BV(A_1_2)) || !(PINA & _BV(A_3_4))) break;
  }
  led_off();
}

// =============================================================================
// MAIN LOOP
// =============================================================================
void loop() {
  wdt_reset();
  
  update_alarm();
  update_temp();
  
  if (temp_now >= TEMP_MAX) {
    enter_state(ERROR);
    alarm_active = false;
    beep_error();
    return;
  }
  
  if (temp_now < TEMP_MIN) {
    if (state != ERROR) enter_state(ERROR);
    return;
  }
  
  BtnEvent btn = read_button();
  
  switch(state) {
    case OFF:       handle_off(btn); break;
    case SELECTING: handle_selecting(btn); break;
    case HEATING:
    case BOILING:   handle_heating_boiling(btn); break;
    case ALARMING:  handle_alarming(btn); break;
    case ERROR:     handle_error(btn); break;
  }
  
  delay(5);
}

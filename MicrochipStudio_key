// Attiny 44A SOP-14 - Smart Kettle Controller
// F_CPU: 8 MHz (internal RC oscillator)
#define F_CPU 8000000UL

// =============================================================================
// ??? КАЛИБРОВКА NTC — МЕНЯЙТЕ ЭТИ ЗНАЧЕНИЯ ПОД СВОЙ ДАТЧИК
// =============================================================================

// Номинал NTC при 25°C (Ом)
#define NTC_R25          50000UL
// Верхний резистор делителя (Ом)
#define DIVIDER_R_TOP    47000UL
// Контрольная точка 1: температура (°C) и сопротивление NTC (Ом)
#define CAL_T1_C         29
#define CAL_R1           45000UL
// Контрольная точка 2: температура (°C) и сопротивление NTC (Ом)
#define CAL_T2_C         65
#define CAL_R2           10800UL

// =============================================================================
// ?? АВТОМАТИЧЕСКИЙ РАСЧЁТ КОЭФФИЦИЕНТОВ (НЕ ТРОГАТЬ!)
// =============================================================================

#define CAL_T1 (CAL_T1_C * 100)
#define CAL_T2 (CAL_T2_C * 100)
#define CAL_ADC1 ((1023UL * CAL_R1) / (DIVIDER_R_TOP + CAL_R1))
#define CAL_ADC2 ((1023UL * CAL_R2) / (DIVIDER_R_TOP + CAL_R2))

#if CAL_ADC1 <= CAL_ADC2
#error "Ошибка: CAL_T1 должна быть холоднее CAL_T2!"
#endif

#define TEMP_B ((CAL_T2 - CAL_T1) / (CAL_ADC1 - CAL_ADC2))
#define TEMP_A (CAL_T1 + CAL_ADC1 * TEMP_B)

// =============================================================================
// HARDWARE CONFIG
// =============================================================================

#include <avr/io.h>
#include <avr/interrupt.h>
#include <avr/wdt.h>
#include <avr/eeprom.h>
#include <util/delay.h>
#include <stdbool.h>

#define LED_R       PB2
#define LED_G       PA7
#define LED_B       PA6
#define BUZZER      PA0
#define RELAY       PA4
#define TEMP_ADC    1
#define A_1_2       PB0  // KEY2
#define A_3_4       PA2  // KEY1
#define C_1_3       PA3
#define C_2_4       PB1

// =============================================================================
// TYPES & CONFIG
// =============================================================================

typedef enum { NONE, BTN1_CLICK, BTN1_HOLD, BTN2_CLICK, BTN2_HOLD_SHORT } BtnEvent;
typedef enum { OFF, SELECTING, HEATING, BOILING, ALARMING, ERROR } State;

const uint8_t PRESET_COLORS[] = {180, 96, 64, 32, 16};
const int16_t TEMP_PRESETS[] = {4000, 5000, 6000, 8000, 9000};

#define TEMP_MAX         10300
#define TEMP_MIN         715
#define TIME_HOLD_SHORT  3000
#define TIME_SELECT      12000
#define TIME_MAX_HEATING 2097152
#define TIME_TEMP_STUCK  262144
#define TIME_ALARM       30000

// =============================================================================
// GLOBAL VARIABLES
// =============================================================================

volatile uint32_t system_millis = 0;
State state = OFF;
int16_t temp_now = 2000;
int16_t temp_target = 0;
uint8_t preset_idx = 0;
uint32_t state_enter_time = 0;
uint32_t temp_last_change = 0;
bool alarm_active = false;
uint32_t alarm_start = 0;
bool partial_boil = false;
uint32_t time_to_60C = 0;
uint8_t boil_detected = 0;
uint32_t last_temp_time = 0;
bool hold_mode = false;          // режим подогрева
uint32_t hold_end_time = 0;      // время окончания подогрева

// =============================================================================
// HARDWARE FUNCTIONS
// =============================================================================

void rgb(uint8_t r, uint8_t g, uint8_t b) {
	OCR0A = 255 - r;
	OCR0B = 255 - g;
	OCR1A = 255 - b;
}

void hsv(uint8_t h, uint8_t v) {
	uint8_t region = h / 43;
	uint8_t remainder = (h - (region * 43)) * 6;
	uint8_t q = (v * (255 - ((255 * remainder) >> 8))) >> 8;
	uint8_t t = (v * (255 - ((255 * (255 - remainder)) >> 8))) >> 8;
	switch(region) {
		case 0: rgb(v, t, 0); break;
		case 1: rgb(q, v, 0); break;
		case 2: rgb(0, v, t); break;
		case 3: rgb(0, q, v); break;
		case 4: rgb(t, 0, v); break;
		default: rgb(v, 0, q); break;
	}
}

void led_off(void) { rgb(0, 0, 0); }

void show_led(uint8_t n) {
	DDRA &= ~(_BV(A_3_4) | _BV(C_1_3));
	DDRB &= ~(_BV(A_1_2) | _BV(C_2_4));
	PORTA |= _BV(A_3_4);
	PORTB |= _BV(A_1_2);
	if (n == 0) return;
	if (n >= 1 && n <= 3) {
		PORTB |= _BV(A_1_2); DDRB |= _BV(A_1_2);
		PORTA &= ~_BV(A_3_4); DDRA |= _BV(A_3_4);
		} else if (n == 4 || n == 5) {
		PORTA |= _BV(A_3_4); DDRA |= _BV(A_3_4);
		PORTB &= ~_BV(A_1_2); DDRB |= _BV(A_1_2);
	}
	if (n == 1) { PORTA &= ~_BV(C_1_3); DDRA |= _BV(C_1_3); }
	else if (n == 2 || n == 3) { PORTB &= ~_BV(C_2_4); DDRB |= _BV(C_2_4); }
	else if (n == 4) { PORTA &= ~_BV(C_1_3); DDRA |= _BV(C_1_3); }
	else if (n == 5) {
		PORTA &= ~_BV(C_1_3); DDRA |= _BV(C_1_3);
		PORTB &= ~_BV(C_2_4); DDRB |= _BV(C_2_4);
	}
}

int16_t read_temp_raw(void) {
	static int16_t hist[3];
	static uint8_t idx = 0;
	ADMUX = (1 << REFS0) | TEMP_ADC;
	ADCSRA = (1 << ADEN) | (1 << ADSC) | (1 << ADPS2) | (1 << ADPS1);
	while (ADCSRA & (1 << ADSC));
	hist[idx++] = ADC;
	idx %= 3;
	int16_t a = hist[0], b = hist[1], c = hist[2];
	int16_t mid = (a < b) ? ((b < c) ? b : ((c < a) ? a : c))
	: ((a < c) ? a : ((c < b) ? b : c));
	if (mid <= 1) mid = 1;
	if (mid >= 1022) mid = 1022;
	return TEMP_A - mid * TEMP_B;
}

void update_temp(void) {
	int16_t raw = read_temp_raw();
	temp_now += (raw - temp_now) / 32;
	static int16_t last_stable = 0;
	int16_t diff = temp_now - last_stable;
	if (diff < 0) diff = -diff;
	if (diff > 100) {
		temp_last_change = system_millis;
		last_stable = temp_now;
	}
}

void play_tone(uint16_t freq_hz, uint16_t duration_ms) {
	if (freq_hz < 100 || freq_hz > 5000 || duration_ms == 0) return;
	uint16_t period_us = 1000000UL / freq_hz;
	uint16_t half_period_us = period_us / 2;
	uint32_t cycles = (uint32_t)duration_ms * 1000 / period_us;
	for (uint32_t i = 0; i < cycles; i++) {
		PORTA |= _BV(BUZZER);
		for (volatile uint16_t t = 0; t < half_period_us * 4; t++) {
			asm volatile("nop");
		}
		PORTA &= ~_BV(BUZZER);
		for (volatile uint16_t t = 0; t < half_period_us * 4; t++) {
			asm volatile("nop");
		}
	}
}

BtnEvent read_button(void) {
	static uint8_t last = 0;
	static uint32_t press_time = 0;
	static uint8_t hold_level = 0;
	uint8_t btn = 0;
	if (!(PINA & _BV(A_3_4))) btn = 1;
	else if (!(PINB & _BV(A_1_2))) btn = 2;
	BtnEvent evt = NONE;
	if (btn && btn == last) {
		uint32_t held = system_millis - press_time;
		if (hold_level == 0 && held > 200) {
			hold_level = 1;
			press_time = system_millis;
			PORTA |= _BV(BUZZER);
			_delay_ms(30);
			PORTA &= ~_BV(BUZZER);
			} else if (hold_level == 1 && held > TIME_HOLD_SHORT) {
			hold_level = 2;
		}
		} else if (!btn && last) {
		if (system_millis - press_time > 200) {
			if (last == 1) evt = BTN1_CLICK;
			else if (hold_level == 1) evt = BTN2_CLICK;
			else if (hold_level == 2) evt = BTN2_HOLD_SHORT;
		}
		hold_level = 0;
		press_time = system_millis;
	}
	last = btn;
	return evt;
}

void update_alarm(void) {
	if (!alarm_active) return;
	uint32_t elapsed = system_millis - alarm_start;
	if (elapsed > TIME_ALARM) {
		alarm_active = false;
		PORTA &= ~_BV(BUZZER);
		return;
	}
	if (elapsed < 10000 || (elapsed >= 20000 && elapsed < 30000)) {
		PORTA |= _BV(BUZZER);
		} else {
		PORTA &= ~_BV(BUZZER);
	}
}

void enter_state(State s) {
	state = s;
	state_enter_time = system_millis;
	if (s == OFF) {
		time_to_60C = 0;
		boil_detected = 0;
		last_temp_time = 0;
		hold_mode = false;
		hold_end_time = 0;
	}
	switch(s) {
		case OFF:
		PORTA &= ~_BV(RELAY); DDRA |= _BV(RELAY);
		led_off(); preset_idx = 0; partial_boil = false;
		break;
		case SELECTING:
		preset_idx = eeprom_read_byte((uint8_t*)0);
		if (preset_idx > 4) preset_idx = 0;
		show_led(preset_idx + 1);
		led_off();
		break;
		case HEATING:
		case BOILING:
		show_led(0);
		PORTA |= _BV(RELAY); DDRA |= _BV(RELAY);
		temp_last_change = system_millis;
		break;
		case ALARMING:
		PORTA &= ~_BV(RELAY);
		alarm_active = true; alarm_start = system_millis;
		hsv(PRESET_COLORS[preset_idx], 255);
		break;
		case ERROR:
		PORTA &= ~_BV(RELAY);
		alarm_active = false; PORTA &= ~_BV(BUZZER);
		led_off();
		break;
	}
}

void handle_off(BtnEvent btn) {
	// === ЗАЩИТА: нельзя запустить, если чайник горячий (>80°C) ===
	if (temp_now > 8000) {
		if (btn != NONE) {
			enter_state(ERROR);
		}
		return;
	}

	if (btn == BTN1_CLICK) {
		partial_boil = false;
		enter_state(BOILING);
		} else if (btn == BTN2_CLICK) {
		enter_state(SELECTING);
	}
}

void handle_selecting(BtnEvent btn) {
	if (btn == BTN1_CLICK) {
		enter_state(OFF);
		} else if (btn == BTN2_CLICK) {
		preset_idx = (preset_idx + 1) % 5;
		show_led(preset_idx + 1);
		state_enter_time = system_millis;
		} else if (btn == BTN2_HOLD_SHORT) {
		eeprom_update_byte((uint8_t*)0, preset_idx);
		show_led(0); _delay_ms(250); show_led(preset_idx + 1);
	}
	if (system_millis - state_enter_time > TIME_SELECT) {
		temp_target = TEMP_PRESETS[preset_idx];
		led_off();
		if (temp_now < temp_target - 350) {
			enter_state(HEATING);
			} else {
			enter_state(OFF);
		}
	}
}

void handle_heating_boiling(BtnEvent btn) {
	static uint8_t brightness = 128;
	static bool dir = true;
	static uint32_t last_breath = 0;

	// === АВТООТКЛЮЧЕНИЕ ПРИ КИПЕНИИ + СУХОЙ НАГРЕВ ===
	if (temp_now >= 9400 && !boil_detected) {
		uint32_t now = system_millis;
		if (last_temp_time == 0) {
			last_temp_time = now;
			} else {
			uint32_t dt = now - last_temp_time;
			if (dt >= 1000 && dt <= 10000) {
				int16_t dT = temp_now - temp_last_change;
				if (dT < 0) dT = -dT;
				uint16_t rate = (uint32_t)dT * 1000 / dt;
				if (rate < 100) {
					boil_detected = 1;
					uint32_t heating_time = system_millis - state_enter_time;
					// === СУХОЙ НАГРЕВ: кипение за <60 секунд ===
					if (heating_time < 60000) {
						led_off();
						enter_state(ERROR);
						return;
					}
					led_off();
					enter_state(ALARMING);
					return;
				}
				last_temp_time = now;
				temp_last_change = temp_now;
			}
		}
	}

	// === ИНДИКАЦИЯ ОБЪЁМА ВОДЫ ===
	uint8_t breath_delay = 30;
	if (time_to_60C > 0) {
		if (time_to_60C < 20000) breath_delay = 15;
		else if (time_to_60C < 40000) breath_delay = 22;
	}

	if (system_millis - last_breath > breath_delay) {
		last_breath = system_millis;
		if (dir) {
			if (++brightness >= 250) dir = false;
			} else {
			if (--brightness <= 5) dir = true;
		}

		int16_t t = temp_now;
		uint8_t hue, final_brightness;
		if (t < 4000) {
			hue = 180;
			final_brightness = (brightness * 60) / 255;
			} else {
			if (t > 9500) t = 9500;
			hue = 180 - ((t - 4000) * 164) / 5500;
			final_brightness = brightness;
		}
		hsv(hue, final_brightness);
	}

	// === ОБРАБОТКА КНОПОК ===
	if (btn == BTN1_HOLD && state == BOILING) {
		partial_boil = !partial_boil;
		hsv(partial_boil ? 32 : 0, 255);
		_delay_ms(1000);
		} else if (btn == BTN1_CLICK) {
		led_off();
		enter_state(OFF);
		return;
	}

	// === ЗАЩИТА ===
	if (system_millis - state_enter_time > TIME_MAX_HEATING ||
	system_millis - temp_last_change > TIME_TEMP_STUCK) {
		led_off();
		enter_state(ERROR);
		return;
	}

	// === ЗАПОМИНАЕМ ВРЕМЯ ДО 60°C ===
	if (temp_now >= 6000 && time_to_60C == 0) {
		time_to_60C = system_millis - state_enter_time;
	}

	// === РЕЗЕРВНЫЙ ТАЙМЕР КИПЯЧЕНИЯ ===
	if (state == BOILING && !boil_detected) {
		uint32_t boil_time = partial_boil ? 300000UL : 1200000UL;
		if (system_millis - state_enter_time > boil_time) {
			led_off();
			enter_state(ALARMING);
		}
	}
}

void handle_alarming(BtnEvent btn) {
	static bool played = false;
	if (!played) {
		played = true;
		uint16_t freq = 1000;
		if (preset_idx == 0) freq = 600;
		else if (preset_idx == 2) freq = 1200;
		else if (preset_idx == 4) freq = 1800;
		play_tone(freq, 200);
		_delay_ms(150);
		play_tone(freq, 200);
	}

	// === УДЕРЖАНИЕ KEY1 ? ВКЛЮЧИТЬ ПОДОГРЕВ НА 20 МИН ===
	if (btn == BTN1_HOLD) {
		hold_mode = true;
		hold_end_time = system_millis + 1200000; // 20 минут
		state = HEATING; // оставляем в HEATING для логики подогрева
		state_enter_time = system_millis;
		hsv(PRESET_COLORS[preset_idx], 100); // тусклый цвет цели
		return;
	}

	if (btn != NONE) {
		alarm_active = false;
		PORTA &= ~_BV(BUZZER);
		enter_state(OFF);
	}
}

void handle_error(BtnEvent btn) {
	static uint32_t beep_time = 0;
	static bool beep_state = false;
	// Определяем тип ошибки: сухой нагрев = оранжевый, иначе = красный
	uint8_t error_hue = 0; // красный по умолчанию
	// Если закипело очень быстро — оранжевый
	if (boil_detected && (system_millis - state_enter_time) < 60000) {
		error_hue = 32; // оранжевый
	}

	if (system_millis - beep_time > 250) {
		beep_time = system_millis;
		beep_state = !beep_state;
		PORTA ^= _BV(BUZZER);
		if (beep_state) {
			hsv(error_hue, 255);
			} else {
			led_off();
		}
	}
	if (btn != NONE) {
		PORTA &= ~_BV(BUZZER);
		enter_state(OFF);
	}
}

ISR(TIM0_COMPA_vect) { system_millis++; }

int main(void) {
	wdt_enable(WDTO_8S);
	DDRA = _BV(LED_G) | _BV(LED_B) | _BV(BUZZER) | _BV(RELAY);
	DDRB = _BV(LED_R);
	PORTA = _BV(A_3_4);
	PORTB = _BV(A_1_2);
	TCCR0A = _BV(COM0A1) | _BV(COM0B1) | _BV(WGM01) | _BV(WGM00);
	TCCR0B = _BV(CS01);
	TCCR1A = _BV(WGM10) | _BV(COM1A1);
	TCCR1B = _BV(WGM12) | _BV(CS11);
	for (int i = 0; i < 3; i++) { read_temp_raw(); _delay_ms(50); }
	update_temp();
	TCCR0A = (1 << WGM01);
	TCCR0B = (1 << CS01) | (1 << CS00);
	OCR0A = 124;
	TIMSK0 = (1 << OCIE0A);
	sei();
	hsv(180, 100); _delay_ms(300); led_off();

	while (1) {
		wdt_reset();
		update_alarm();
		update_temp();

		// === ЛОГИКА ПОДОГРЕВА ===
		if (hold_mode) {
			if (system_millis > hold_end_time) {
				hold_mode = false;
				enter_state(OFF);
				} else if (temp_now < (temp_target - 300)) {
		// Включить реле на 10 сек при остывании
				if ((system_millis - state_enter_time) > 10000) {
					PORTA |= _BV(RELAY);
					state_enter_time = system_millis;
				}
				} else {
				PORTA &= ~_BV(RELAY);
			}
		}

		if (temp_now >= TEMP_MAX) { enter_state(ERROR); continue; }
		if (temp_now < TEMP_MIN) { if (state != ERROR) enter_state(ERROR); continue; }

		BtnEvent btn = read_button();
		switch(state) {
			case OFF:       handle_off(btn); break;
			case SELECTING: handle_selecting(btn); break;
			case HEATING:
			case BOILING:   handle_heating_boiling(btn); break;
			case ALARMING:  handle_alarming(btn); break;
			case ERROR:     handle_error(btn); break;
		}
		_delay_ms(5);
	}
}

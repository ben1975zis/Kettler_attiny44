// Attiny 44A DIP-14 - Smart Kettle Controller
// F_CPU: 8 MHz (internal RC oscillator)
#include <avr/io.h>
#include <avr/interrupt.h>
#include <avr/wdt.h>
#include <avr/eeprom.h>
#include <util/delay.h>
#include <stdbool.h>

// =============================================================================
// HARDWARE CONFIG
// =============================================================================
#define LED_R       PB2  // PWM OC0A - pin 5
#define LED_G       PA7  // PWM OC0B - pin 6
#define LED_B       PA6  // PWM OC1A - pin 7
#define BUZZER      PA5  // - pin 8
#define RELAY       PA4  // - pin 9
#define TEMP_ADC    1    // ADC1 (PA1 - pin 12)
// LED Matrix + Buttons
#define A_1_2       PB0  // pin 2 (KEY2)
#define A_3_4       PA2  // pin 11 (KEY1)
#define C_1_3       PA3  // pin 10
#define C_2_4       PB1  // pin 3
#define EXTRA_PIN   PB3  // pin 4
// =============================================================================
// TYPES
// =============================================================================
typedef enum {
	NONE, BTN1_CLICK, BTN1_HOLD, BTN2_CLICK, BTN2_HOLD_SHORT, BTN2_HOLD_LONG
} BtnEvent;
typedef enum {
	OFF, SELECTING, HEATING, BOILING, ALARMING, ERROR
} State;
// =============================================================================
// CONFIGURATION
// =============================================================================
const uint8_t PRESET_COLORS[] = {180, 96, 64, 32, 16};  // 40, 50, 60, 80, 90
const int16_t TEMP_PRESETS[] = {4000, 5000, 6000, 8000, 9000};
// === Effects timing: 8 modes ===
const uint8_t arrTimeEff[] = {
	255, 128, 64, 32,     // 1-4: hue sweep
	255, 128, 64, 32      // 5-8: temperature pulsation
};
#define TEMP_MAX         10300
#define TEMP_MIN         715
#define TEMP_BOIL        9500
#define TIME_MAX_HEATING  2097152
#define TIME_TEMP_STUCK   262144
#define TIME_ALARM        30000
#define TIME_DEBOUNCE     200
#define TIME_HOLD_SHORT   3000
#define TIME_HOLD_LONG    12000
#define TIME_SELECT       12000
#define TIME_EFFECT_MAX   1200000
// =============================================================================
// GLOBAL STATE
// =============================================================================
volatile uint32_t system_millis = 0;
State state = OFF;
int16_t temp_now = 2000;
int16_t temp_target = 0;
int16_t temp_compensation = -150;
uint8_t preset_idx = 0;
uint32_t state_enter_time = 0;
uint32_t temp_last_change = 0;
bool alarm_active = false;
uint32_t alarm_start = 0;
uint8_t ledsMode = 0;
uint8_t effectMode = 0;
uint32_t effectCount = 0;
uint8_t ledsColor = 0;
uint8_t ledsBright = 0;
bool ledsDir = true;
bool partial_boil = false;
// =============================================================================
// HARDWARE ABSTRACTION
// =============================================================================
void rgb(uint8_t r, uint8_t g, uint8_t b) {
	OCR0A = 255 - r;
	OCR0B = 255 - g;
	OCR1A = 255 - b;
}
void hsv(uint8_t h, uint8_t v) {
	uint8_t s = h / 43;
	uint8_t f = (h - s * 43) * 6;
	uint8_t q = (v * (255 - f)) >> 8;
	uint8_t t = (v * f) >> 8;
	switch(s) {
		case 0: rgb(v, t, 0); break;
		case 1: rgb(q, v, 0); break;
		case 2: rgb(0, v, t); break;
		case 3: rgb(0, q, v); break;
		case 4: rgb(t, 0, v); break;
		default: rgb(v, 0, q);
	}
}
void led_off(void) { rgb(0, 0, 0); }

void showColorTemp(void) {
	int16_t t = temp_now;
	if (t < 4000) t = 4000;
	if (t > 9500) t = 9500;
	uint8_t hue = 180 - ((t - 4000) * 164) / 5500;  // 180 (blue) to 16 (red-orange)
	hsv(hue, 255);
}

void show_led(uint8_t n) {
	DDRA &= ~(_BV(A_3_4) | _BV(C_1_3));
	DDRB &= ~(_BV(A_1_2) | _BV(C_2_4));
	PORTA |= _BV(A_3_4);
	PORTB |= _BV(A_1_2);
	if (n == 0) return;
	if (n >= 1 && n <= 3) {
		PORTB |= _BV(A_1_2);
		DDRB |= _BV(A_1_2);
		PORTA &= ~_BV(A_3_4);
		DDRA |= _BV(A_3_4);
		} else if (n == 4 || n == 5) {
		PORTA |= _BV(A_3_4);
		DDRA |= _BV(A_3_4);
		PORTB &= ~_BV(A_1_2);
		DDRB |= _BV(A_1_2);
	}
	switch(n) {
		case 1: PORTA &= ~_BV(C_1_3); DDRA |= _BV(C_1_3); break;
		case 2:
		case 3: PORTB &= ~_BV(C_2_4); DDRB |= _BV(C_2_4); break;
		case 4: PORTA &= ~_BV(C_1_3); DDRA |= _BV(C_1_3); break;
		case 5:
		PORTA &= ~_BV(C_1_3); DDRA |= _BV(C_1_3);
		PORTB &= ~_BV(C_2_4); DDRB |= _BV(C_2_4);
		break;
	}
}

int16_t read_temp_raw(void) {
	static int16_t hist[3];
	static uint8_t idx = 0;
	ADMUX = (1 << REFS0) | TEMP_ADC;
	ADCSRA = (1 << ADEN) | (1 << ADSC) | (1 << ADPS2) | (1 << ADPS1);
	while (ADCSRA & (1 << ADSC));
	hist[idx++] = ADC;
	idx %= 3;
	int16_t a = hist[0], b = hist[1], c = hist[2];
	int16_t mid = (a < b) ? ((b < c) ? b : ((c < a) ? a : c))
	: ((a < c) ? a : ((c < b) ? b : c));
	return (mid > 558) ? (18291 - mid * 26) : (13820 - mid * 18);
}

void update_temp(void) {
	int16_t raw = read_temp_raw();
	temp_now += (raw - temp_now) / 32;
	static int16_t last_stable = 0;
	int16_t diff = temp_now - last_stable;
	if (diff < 0) diff = -diff;
	if (diff > 100) {
		temp_last_change = system_millis;
		last_stable = temp_now;
	}
}

uint8_t rand255(void) {
	uint8_t temp = 0;
	for(uint8_t i = 0; i < 8; i += 2) {
		temp |= ((read_temp_raw() ^ ledsColor) & 0b11) << i;
	}
	return temp;
}

void effectInit(void) {
	ledsColor = rand255();
	ledsBright = 0;
}
void effectOff(void) {
	if (effectMode > 0) {
		eeprom_update_byte((uint8_t*)1, effectMode);
	}
	effectMode = 0;
	led_off();
}

void showEffectMode(uint8_t mode) {
	static uint32_t ledsCount = 0;
	if (mode > 0 && mode <= 8) {
		if (system_millis - ledsCount >= arrTimeEff[mode - 1]) {
			ledsCount = system_millis;
			if (mode <= 4) {
				// Hue sweep modes
				ledsColor++;
				hsv(ledsColor, 255);
				} else {
				// Temperature pulsation modes (5-8)
				if (ledsBright == 0) {
					ledsDir = true;
					ledsColor = 180 - ((temp_now - 4000) * 164) / 5500;
				}
				if (ledsDir) {
					ledsBright++;
					if (ledsBright == 255)
					ledsDir = false;
					} else {
					ledsBright--;
				}
				hsv(ledsColor, ledsBright);
			}
		}
		} else {
		showColorTemp();
	}
}

BtnEvent read_button(void) {
	static uint8_t last = 0;
	static uint32_t press_time = 0;
	static uint8_t hold_level = 0;
	show_led(0);
	_delay_us(100);
	uint8_t btn = 0;
	if (!(PINA & _BV(A_3_4))) btn = 1;
	else if (!(PINB & _BV(A_1_2))) btn = 2;
	if (effectMode == 0) show_led(preset_idx + 1);
	BtnEvent evt = NONE;
	if (btn && btn == last) {
		uint32_t held = system_millis - press_time;
		if (hold_level == 0 && held > TIME_DEBOUNCE) {
			hold_level = 1;
			press_time = system_millis;
			PORTA |= _BV(BUZZER);
			_delay_ms(30);
			PORTA &= ~_BV(BUZZER);
			} else if (hold_level == 1 && held > TIME_HOLD_SHORT) {
			hold_level = 2;
			} else if (hold_level == 2 && held > TIME_HOLD_LONG - TIME_HOLD_SHORT) {
			hold_level = 3;
		}
		} else if (!btn && last) {
		if (system_millis - press_time > TIME_DEBOUNCE) {
			if (last == 1) {
				evt = (hold_level < 2) ? BTN1_CLICK : BTN1_HOLD;
				} else {
				if (hold_level == 1) evt = BTN2_CLICK;
				else if (hold_level == 2) evt = BTN2_HOLD_SHORT;
				else if (hold_level == 3) evt = BTN2_HOLD_LONG;
			}
		}
		hold_level = 0;
		press_time = system_millis;
	}
	last = btn;
	return evt;
}

void update_led_effect(void) {
	static uint32_t last_frame = 0;
	if (system_millis - last_frame < 25) return;
	last_frame = system_millis;
	if (ledsBright == 0) {
		ledsDir = true;
		ledsColor = 180 - ((temp_now - 4000) * 164) / 5500;
	}
	ledsBright += ledsDir ? 1 : -1;
	if (ledsBright == 255) ledsDir = false;
	hsv(ledsColor, ledsBright);
}

void update_alarm(void) {
	if (!alarm_active) return;
	uint32_t elapsed = system_millis - alarm_start;
	if (elapsed > TIME_ALARM) {
		alarm_active = false;
		PORTA &= ~_BV(BUZZER);
		return;
	}
	if (elapsed < 10000) {
		PORTA |= _BV(BUZZER);
		} else if (elapsed < 20000) {
		PORTA &= ~_BV(BUZZER);
		} else if (elapsed < 30000) {
		PORTA |= _BV(BUZZER);
	}
}

void enter_state(State s) {
	state = s;
	state_enter_time = system_millis;
	switch(s) {
		case OFF:
		PORTA &= ~_BV(RELAY); DDRA |= _BV(RELAY);
		led_off(); preset_idx = 0; partial_boil = false;
		break;
		case SELECTING:
		preset_idx = eeprom_read_byte((uint8_t*)0);
		if (preset_idx > 4) preset_idx = 0;
		show_led(preset_idx + 1);
		hsv(PRESET_COLORS[preset_idx], 255);
		break;
		case HEATING:
		case BOILING:
		show_led(0); led_off();
		PORTA |= _BV(RELAY); DDRA |= _BV(RELAY);
		temp_last_change = system_millis;
		temp_compensation = -150;
		ledsColor = 0; ledsBright = 0;
		break;
		case ALARMING:
		PORTA &= ~_BV(RELAY); DDRA |= _BV(RELAY);
		alarm_active = true; alarm_start = system_millis;
		PORTA |= _BV(BUZZER);
		break;
		case ERROR:
		PORTA &= ~_BV(RELAY); DDRA |= _BV(RELAY);
		alarm_active = false; PORTA &= ~_BV(BUZZER);
		break;
	}
}

void handle_off(BtnEvent btn) {
	if (btn == BTN1_CLICK) {
		partial_boil = false;
		enter_state(BOILING);
		} else if (btn == BTN2_CLICK) {
		enter_state(SELECTING);
		} else if (btn == BTN2_HOLD_LONG) {
		effectMode = 1;
		effectCount = system_millis;
		effectInit();
	}
}
void handle_selecting(BtnEvent btn) {
	if (btn == BTN1_CLICK) {
		enter_state(OFF);
		} else if (btn == BTN2_CLICK) {
		preset_idx = (preset_idx + 1) % 5;
		show_led(preset_idx + 1);
		hsv(PRESET_COLORS[preset_idx], 255);
		state_enter_time = system_millis;
		} else if (btn == BTN2_HOLD_SHORT) {
		eeprom_update_byte((uint8_t*)0, preset_idx);
		show_led(0); _delay_ms(250); show_led(preset_idx + 1);
	}
	if (system_millis - state_enter_time > TIME_SELECT) {
		temp_target = TEMP_PRESETS[preset_idx];
		if (temp_now < temp_target - 350) {
			enter_state(HEATING);
			} else {
			enter_state(OFF);
		}
	}
}
void handle_heating_boiling(BtnEvent btn) {
	if (state == HEATING) update_led_effect();
	if (btn == BTN1_HOLD && state == BOILING) {
		partial_boil = !partial_boil;
		hsv(partial_boil ? 32 : 0, 255);
		_delay_ms(1000);
		led_off();
		} else if (btn == BTN1_CLICK) {
		enter_state(OFF);
		return;
	}
	if (system_millis - state_enter_time > TIME_MAX_HEATING ||
	system_millis - temp_last_change > TIME_TEMP_STUCK) {
		enter_state(ERROR);
		return;
	}
	static int16_t last_calc = 0;
	static uint32_t calc_time = 0;
	if (last_calc == 0) {
		last_calc = temp_now;
		calc_time = system_millis;
		} else if (temp_now > last_calc + 100) {
		uint32_t dt = system_millis - calc_time;
		if (dt > 1000) {
			uint16_t rate = (temp_now - last_calc) * 10000UL / dt;
			if (rate > 5000) { enter_state(ERROR); return; }
			if (rate >= 1300) temp_compensation = -1180;
			else if (rate > 720) temp_compensation = 120 - rate;
			else if (rate > 200) temp_compensation = 253796UL / rate - 933;
			else temp_compensation = 350;
			last_calc = temp_now;
			calc_time = system_millis;
		}
	}
	if (state == HEATING) {
		if (temp_now >= temp_target + temp_compensation) {
			enter_state(ALARMING);
		}
		} else {
		static uint32_t boil_start = 0;
		if (temp_now > TEMP_BOIL && boil_start == 0) boil_start = system_millis;
		if (boil_start > 0) {
			uint32_t boil_time = 16000;
			uint32_t elapsed = system_millis - calc_time;
			if (elapsed > 0 && elapsed < 10000) {
				uint16_t rate = (temp_now - last_calc) * 10000UL / elapsed;
				if (rate > 0) {
					if (rate > 3000) rate = 3000;
					else if (rate < 272) rate = 272;
					boil_time = 19082305UL / rate + 5375;
				}
			}
			if (partial_boil) boil_time /= 4;
			if (system_millis - boil_start > boil_time) {
				enter_state(ALARMING);
			}
		}
	}
}
void handle_alarming(BtnEvent btn) {
	if (btn != NONE) {
		alarm_active = false;
		PORTA &= ~_BV(BUZZER);
		enter_state(OFF);
	}
}
void handle_error(BtnEvent btn) {
	// Alarm beeping pattern
	static uint32_t beep_time = 0;
	static bool beep_state = false;
	
	if (system_millis - beep_time > 250) {
		beep_time = system_millis;
		beep_state = !beep_state;
		if (beep_state) {
			PORTA |= _BV(BUZZER);   // Beep ON
			hsv(0, 255);            // Red LED
			} else {
			PORTA &= ~_BV(BUZZER);  // Beep OFF
			led_off();
		}
	}
	
	if (btn != NONE) {
		PORTA &= ~_BV(BUZZER);  // Turn off buzzer
		enter_state(OFF);
	}
}

void timer0_init(void) {
	TCCR0A = (1 << WGM01);
	TCCR0B = (1 << CS01) | (1 << CS00);
	OCR0A = 124;
	TIMSK0 = (1 << OCIE0A);
}
ISR(TIM0_COMPA_vect) { system_millis++; }

int main(void) {
	wdt_enable(WDTO_8S);
	DDRA = _BV(LED_G) | _BV(LED_B) | _BV(BUZZER) | _BV(RELAY);
	DDRB = _BV(LED_R) | _BV(EXTRA_PIN);
	PORTA = _BV(A_3_4);
	PORTB = _BV(A_1_2) | _BV(EXTRA_PIN);
	TCCR0A = _BV(COM0A1) | _BV(COM0B1) | _BV(WGM01) | _BV(WGM00);
	TCCR0B = _BV(CS01);
	TCCR1A = _BV(WGM10) | _BV(COM1A1);
	TCCR1B = _BV(WGM12) | _BV(CS11);
	for (int i = 0; i < 3; i++) { read_temp_raw(); _delay_ms(50); }
	update_temp();

	// Startup indication
	hsv(180, 255);  // Blue
	_delay_ms(300);
	led_off();

	// Load effect mode from EEPROM
	ledsMode = eeprom_read_byte((uint8_t*)1);
	if (ledsMode == 0 || ledsMode > 8) ledsMode = 1;
	effectMode = ledsMode;

	timer0_init();
	sei();
	while (1) {
		wdt_reset();
		update_alarm();
		update_temp();
		if (effectMode) {
			if (system_millis - effectCount > TIME_EFFECT_MAX) {
				effectOff();
				} else {
				showEffectMode(effectMode);
				BtnEvent btn = read_button();
				if (btn == BTN2_HOLD_SHORT) {
					effectMode = effectMode % 8 + 1;
					effectCount = system_millis;
					effectInit();
					} else if (btn != NONE) {
					effectOff();
				}
				_delay_ms(5);
				continue;
			}
		}
		if (temp_now >= TEMP_MAX) { enter_state(ERROR); continue; }
		if (temp_now < TEMP_MIN) { if (state != ERROR) enter_state(ERROR); continue; }
		BtnEvent btn = read_button();
		switch(state) {
			case OFF:       handle_off(btn); break;
			case SELECTING: handle_selecting(btn); break;
			case HEATING:
			case BOILING:   handle_heating_boiling(btn); break;
			case ALARMING:  handle_alarming(btn); break;
			case ERROR:     handle_error(btn); break;
		}
		_delay_ms(5);
	}
}     
        _delay_ms(5);
    }
}
